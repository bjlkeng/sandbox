<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Optimization Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui/build/dat.gui.min.js"></script>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script>
        let scene, camera, renderer, surface, optimizerPath, currentPosition, optimizationAlgorithm;
        let isAnimating = false;
        let initX = 1.4, initY = -0.8, learningRate = 0.15, iteration = 0;
        let markers = [];
        let memory = {};
        const algorithms = {
            'Gradient Descent': gradientDescent,
            'Nonlinear Conjugate Gradient': nonlinearConjugateGradient,
            'Nesterov Momentum': nesterovMomentum,
            'RMSProp': rmsProp,
            'Adam': adam,
            'Hypergradient Descent': hypergradientDescent
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.update();

            // Log camera direction on change
            controls.addEventListener('change', () => {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
            });
            
            // Create surface
            const geometry = new THREE.PlaneGeometry(4, 4, 100, 100);
            const material = new THREE.MeshPhongMaterial({
                color: 0x318DCE,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide,
            });
            
            // Add texture
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg');
            material.map = texture;
            material.needsUpdate = true;

            surface = new THREE.Mesh(geometry, material);
            scene.add(surface);

            // Update vertex positions to create a multi-modal surface
            const positions = surface.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                positions[i + 2] = getZPosition(x, y);
            }
            surface.geometry.attributes.position.needsUpdate = true;

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 0, 10).normalize();
            scene.add(directionalLight);

            // Initialize optimizer path
            const pathGeometry = new THREE.BufferGeometry();
            const pathMaterial = new THREE.LineBasicMaterial({ color: 0xDCC703 });
            optimizerPath = new THREE.Line(pathGeometry, pathMaterial);
            scene.add(optimizerPath);

            // Initialize current position marker
            const markerGeometry = new THREE.SphereGeometry(0.1);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xDCC703 });
            currentPosition = new THREE.Mesh(markerGeometry, markerMaterial);
            scene.add(currentPosition);

            // GUI for controlling the visualization
            const gui = new dat.GUI();
            const params = {
                initX: initX,
                initY: initY,
                learningRate: learningRate,
                startOptimization: () => {
                    addMarker(initX, initY, getZPosition(initX, initY));
                    if (!isAnimating) {
                        isAnimating = true;
                        optimizationStep();
                    }
                },
                resetOptimization: () => {
                    isAnimating = false;
                    resetOptimizationPath();
                },
                resetCamera: () => {
                    resetCamera();
                },
                selectAlgorithm: 'Gradient Descent'
            };
            optimizationAlgorithm = algorithms[params.selectAlgorithm];
            gui.add(params, 'selectAlgorithm', Object.keys(algorithms)).name('Algorithm').onChange(value => {
                console.log('Selected algorithm:', value);
                optimizationAlgorithm = algorithms[value];
                resetOptimizationPath();
            });
            gui.add(params, 'startOptimization');
            gui.add(params, 'resetOptimization');
            gui.add(params, 'resetCamera');
            gui.add(params, 'initX').onChange(value => {
                initX = value;
                resetOptimizationPath();
            });
            gui.add(params, 'initY').onChange(value => {
                initY = value;
                resetOptimizationPath();
            });
            gui.add(params, 'learningRate').onChange(value => {
                learningRate = value;
                resetOptimizationPath();
            });
            resetOptimizationPath();
            resetCamera();
            animate();
        }

        function addMarker(x, y, z) {
            const markerGeometry = new THREE.SphereGeometry(0.03);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, y, z);
            scene.add(marker);
            markers.push(marker);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function resetCamera() {
            // Add orbit controls for camera rotation
            camera.position.set(-2.5, 1.07, 2.0);
            camera.up.set(0, 0, 1);
            camera.lookAt(0.69, -.40, .60);
        }

        function resetOptimizationPath() {
            isAnimating = false;
            iteration = 1;
            optimizerPath.geometry.setFromPoints([]);
            currentPosition.position.set(initX, initY, getZPosition(initX, initY));
            // clear markers
            markers.forEach(marker => scene.remove(marker));
            markers = [];
            memory = {};
        }

        function getZPosition(x, y) {
            return Math.sin(x) * Math.cos(y) + Math.cos(2 * x) * Math.sin(2 * y);
        }

        function getGradient(currentPos) {
            const dx = Math.cos(currentPos.x) * Math.cos(currentPos.y) - 2 * Math.sin(2 * currentPos.x) * Math.sin(2 * currentPos.y);
            const dy = -Math.sin(currentPos.x) * Math.sin(currentPos.y) + 2 * Math.cos(2 * currentPos.x) * Math.cos(2 * currentPos.y);
            return {
                x: dx,
                y: dy
            };
        }

        function gradientDescent(currentPos) {
            // Simple gradient descent
            const gradient = getGradient(currentPos);
            const dx = gradient.x;
            const dy = gradient.y;
            
            return {
                x: currentPos.x - learningRate * dx,
                y: currentPos.y - learningRate * dy
            };
        }

        function nonlinearConjugateGradient(currentPos, N = 40) {
            // Compute gradients
            const gradient = getGradient(currentPos);
            const dx = gradient.x;
            const dy = gradient.y;

            if (Object.keys(memory).length === 0) {
                // Initial conditions
                var cgdx = -dx;
                var cgdy = -dy;
            } else {
                // Compute beta via Polak-Ribiere method
                const beta = Math.max(0, ((dx * (dx - memory['cgdx']) + dy * (dy - memory['cgdy']))
                                          / (memory['cgdx'] * memory['cgdx'] + memory['cgdy'] * memory['cgdy'])));

                // Compute approximate gradients
                var cgdx = -dx + beta * memory['cgdx'];
                var cgdy = -dy + beta * memory['cgdy'];
            }

            let nextPos = backtrackingLineSearch(currentPos, cgdx, cgdy, learningRate);
            memory['cgdx'] = cgdx;
            memory['cgdy'] = cgdy;

            return nextPos;
        }

        function nesterovMomentum(currentPos, beta=0.9) {
            if (Object.keys(memory).length === 0) {
                // Initial momentum
                memory['vx'] = 0;
                memory['vy'] = 0;
            }
            projPos = {
                x: currentPos.x + beta * memory['vx'],
                y: currentPos.y + beta * memory['vy']
            }
            const grad = getGradient(projPos);
            const v = {
                x: beta * memory['vx'] - learningRate * grad.x,
                y: beta * memory['vy'] - learningRate * grad.y
            }
            memory['vx'] = v.x;
            memory['vy'] = v.y;

            return {
                x: currentPos.x + v.x,
                y: currentPos.y + v.y
            };
        }

        function rmsProp(currentPos, gamma=0.9, eps=1e-8) {
            if (Object.keys(memory).length === 0) {
                // Initial momentum
                memory['sx'] = 0;
                memory['sy'] = 0;
            }
            
            const grad = getGradient(currentPos);
            const s = {
                x: gamma * memory['sx'] + (1 - gamma) * grad.x * grad.x,
                y: gamma * memory['sy'] + (1 - gamma) * grad.y * grad.y
            }
            memory['sx'] = s.x;
            memory['sy'] = s.y;

            return {
                x: currentPos.x - learningRate * grad.x / (eps + Math.sqrt(s.x)),
                y: currentPos.y - learningRate * grad.y / (eps + Math.sqrt(s.y))
            };
        }
        
        function adam(currentPos, beta1=0.7, beta2=0.9, eps=1e-8) {
            if (Object.keys(memory).length === 0) {
                // Initial momentum
                memory['m'] = { x: 0, y: 0 };
                memory['v'] = { x: 0, y: 0 };
            }
            
            const grad = getGradient(currentPos);
            memory['m'] = {
                x: beta1 * memory['m'].x + (1 - beta1) * grad.x,
                y: beta1 * memory['m'].y + (1 - beta1) * grad.y
            };
            memory['v'] = {
                x: beta2 * memory['v'].x + (1 - beta2) * grad.x * grad.x,
                y: beta2 * memory['v'].y + (1 - beta2) * grad.y * grad.y
            };
            const mHat = {
                x: memory['m'].x / (1 - Math.pow(beta1, iteration)),
                y: memory['m'].y / (1 - Math.pow(beta1, iteration))
            };
            const vHat = {
                x: memory['v'].x / (1 - Math.pow(beta2, iteration)),
                y: memory['v'].y / (1 - Math.pow(beta2, iteration))
            };

            return {
                x: currentPos.x - learningRate * mHat.x / (eps + Math.sqrt(vHat.x)),
                y: currentPos.y - learningRate * mHat.y / (eps + Math.sqrt(vHat.y))
            };
        }

        function hypergradientDescent(currentPos, hypergradient_lr=0.01) {
            if (Object.keys(memory).length === 0) {
                // Initial momentum
                memory['alpha'] = learningRate;
                memory['g'] = { x: 0, y: 0 };
            }
            const grad = getGradient(currentPos);
            memory['alpha'] = memory['alpha'] + hypergradient_lr * (grad.x * memory['g'].x + grad.y * memory['g'].y);
            memory['g'] = { x: grad.x, y: grad.y };
            return {
                x: currentPos.x - memory['alpha'] * grad.x,
                y: currentPos.y - memory['alpha'] * grad.y
            }
        }

        function backtrackingLineSearch(currentPos, dx, dy, alpha, p=0.5, beta=1e-4) {
            z = getZPosition(currentPos.x, currentPos.y);
            let newPos = { x: currentPos.x, y: currentPos.y };
            while (getZPosition(newPos.x + alpha * dx, newPos.y + alpha * dy) 
                   > z + beta * alpha * (dx * dx + dy * dy)) {
                var alpha = alpha * p;
            }
            return { x: newPos.x + alpha * dx, y: newPos.y + alpha * dy };
        }

        function optimizationStep() {
            if (!isAnimating) return;

            const currentPos = currentPosition.position;
            const newPos = optimizationAlgorithm(currentPos);

            if (Math.abs(currentPos.x - newPos.x) < 0.001 && Math.abs(currentPos.y - newPos.y) < 0.001) {
                isAnimating = false;
                // display final position and number of iterations
                console.log('Optimization finished:', currentPos, 'with', iteration, 'iterations');
                return;
            } else if (iteration > 50) {
                isAnimating = false;
                console.log('Optimization terminated at max iterations:', currentPos, 'with', iteration, 'iterations');
                return;
            }
            
            currentPos.x = newPos.x;
            currentPos.y = newPos.y;
            currentPos.z = getZPosition(newPos.x, newPos.y);
            addMarker(currentPos.x, currentPos.y, currentPos.z);

            const pathPoints = optimizerPath.geometry.getAttribute('position').array;
            const newPathPoints = [...pathPoints, currentPos.x, currentPos.y, currentPos.z];
            optimizerPath.geometry.setAttribute('position', new THREE.Float32BufferAttribute(newPathPoints, 3));

            iteration++;
            setTimeout(optimizationStep, 100);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        init();
    </script>
</body>
</html>